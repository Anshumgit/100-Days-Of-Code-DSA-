Day 7: Greedy Algorithms & Array Optimization

Date: January 8, 2026

ğŸ“ Daily Summary
Day 7 of the #100DaysOfCode challenge was dedicated to mastering greedy techniques and array-based optimization problems. I solved classic interview-level problems that focus on making optimal decisions at each step to achieve efficient solutions.

ğŸ’» What I Did Today

Solved 3 medium-to-hard array problems

Implemented Kadaneâ€™s Algorithm for Maximum Subarray Sum

Used running sum and reset logic

Achieved O(n) time complexity

Solved Minimize the Heights Difference problem

Applied sorting + greedy partitioning

Carefully handled negative height constraints

Implemented Minimum Jumps to Reach End

Used greedy range expansion technique

Tracked maxReach, lastReach, and jump count

Achieved O(n) time and O(1) space

Wrote clean, optimized C++ solutions using STL

Strengthened problem-solving speed and confidence with greedy logic

ğŸ’¡ Key Learnings

Greedy algorithms rely on locally optimal choices that lead to a global optimum

Kadaneâ€™s Algorithm is a powerful pattern for subarray-based problems

Sorting often simplifies greedy decisions in optimization problems

Tracking ranges (instead of brute force) is key to efficient jump problems

Edge-case handling (negative values, unreachable states) is crucial

ğŸš© Challenges Overcome

Understanding why greedy works instead of brute force

Managing boundary conditions in height minimization

Avoiding unnecessary jumps and detecting unreachable cases

Translating problem intuition into minimal-variable logic

ğŸ“ˆ Progress Reflection

Todayâ€™s problems significantly improved my confidence in array manipulation and greedy thinking, both of which are essential for coding interviews and competitive programming. Feeling more comfortable tackling optimization-based questions now.
